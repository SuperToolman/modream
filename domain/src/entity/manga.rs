//! `SeaORM` Entity, @generated by sea-orm-codegen 2.0.0-rc.11
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "Manga")]
pub struct Model {
    #[sea_orm(column_name = "Id", primary_key)]
    pub id: i32,
    #[sea_orm(column_name = "CreateTime", column_type = "custom(\"DATETIME\")")]
    pub create_time: String,
    #[sea_orm(column_name = "UpdateTime", column_type = "custom(\"DATETIME\")")]
    pub update_time: String,
    #[sea_orm(column_name = "Cover", column_type = "Text", nullable)]
    pub cover: Option<String>,
    #[sea_orm(column_name = "Title", column_type = "Text")]
    pub title: String,
    #[sea_orm(column_name = "Description", column_type = "Text", nullable)]
    pub description: Option<String>,
    #[sea_orm(column_name = "Path", column_type = "Text")]
    pub path: String,
    #[sea_orm(column_name = "PageCount")]
    pub page_count: i32,
    #[sea_orm(column_name = "ByteSize")]
    pub byte_size: i32,
    #[sea_orm(column_name = "MangaTypeString", column_type = "Text")]
    pub manga_type_string: String,
    #[sea_orm(column_name = "AuthorId")]
    pub author_id: Option<i32>,
    #[sea_orm(column_name = "MediaLibraryId")]
    pub media_library_id: i32,
    #[sea_orm(column_name = "HasChapters")]
    pub has_chapters: bool,
    #[sea_orm(column_name = "ImagePaths", column_type = "Text", nullable)]
    pub image_paths: Option<String>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::media_library::Entity",
        from = "Column::MediaLibraryId",
        to = "super::media_library::Column::Id"
    )]
    MediaLibrary,

    #[sea_orm(has_many = "super::manga_chapter::Entity")]
    Chapters,
}

impl Related<super::media_library::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::MediaLibrary.def()
    }
}

impl Related<super::manga_chapter::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Chapters.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

// ============================================================================
// 业务方法（充血模型）
// ============================================================================

impl Model {
    /// 创建新漫画（工厂方法）
    ///
    /// # 参数
    /// - `title`: 漫画标题
    /// - `path`: 漫画路径
    /// - `page_count`: 页数
    /// - `byte_size`: 字节大小
    /// - `manga_type_string`: 漫画类型
    /// - `media_library_id`: 所属媒体库 ID
    /// - `has_chapters`: 是否有章节结构
    ///
    /// # 返回
    /// - `anyhow::Result<Self>` - 创建的漫画实体
    ///
    /// # 业务规则
    /// - 标题不能为空，长度不超过 200 个字符
    /// - 路径不能为空，必须存在
    /// - 页数必须大于等于 0
    /// - 字节大小必须大于等于 0
    pub fn new(
        title: String,
        path: String,
        page_count: i32,
        byte_size: i32,
        manga_type_string: String,
        media_library_id: i32,
        has_chapters: bool,
    ) -> anyhow::Result<Self> {
        // 使用领域服务验证业务规则
        crate::service::MangaDomainService::validate_title(&title)?;
        crate::service::MangaDomainService::validate_path(&path)?;
        crate::service::MangaDomainService::validate_page_count(page_count)?;
        crate::service::MangaDomainService::validate_byte_size(byte_size)?;
        crate::service::MangaDomainService::validate_manga_type(&manga_type_string)?;

        let now = chrono::Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
        Ok(Self {
            id: 0, // 数据库会自动生成
            title,
            path,
            page_count,
            byte_size,
            manga_type_string,
            media_library_id,
            has_chapters,
            author_id: None,
            description: None,
            cover: None,
            image_paths: None,
            create_time: now.clone(),
            update_time: now,
        })
    }

    /// 更新标题
    ///
    /// # 参数
    /// - `new_title`: 新标题
    ///
    /// # 业务规则
    /// - 标题不能为空，长度不超过 200 个字符
    pub fn update_title(&mut self, new_title: String) -> anyhow::Result<()> {
        crate::service::MangaDomainService::validate_title(&new_title)?;
        self.title = new_title;
        self.update_time = chrono::Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
        Ok(())
    }

    /// 设置封面
    ///
    /// # 参数
    /// - `cover_url`: 封面 URL
    pub fn set_cover(&mut self, cover_url: String) {
        self.cover = Some(cover_url);
        self.update_time = chrono::Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
    }

    /// 清除封面
    pub fn clear_cover(&mut self) {
        self.cover = None;
        self.update_time = chrono::Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
    }

    /// 更新页数
    ///
    /// # 参数
    /// - `new_count`: 新页数
    ///
    /// # 业务规则
    /// - 页数必须大于等于 0
    pub fn update_page_count(&mut self, new_count: i32) -> anyhow::Result<()> {
        crate::service::MangaDomainService::validate_page_count(new_count)?;
        self.page_count = new_count;
        self.update_time = chrono::Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
        Ok(())
    }

    /// 更新字节大小
    ///
    /// # 参数
    /// - `new_size`: 新字节大小
    ///
    /// # 业务规则
    /// - 字节大小必须大于等于 0
    pub fn update_byte_size(&mut self, new_size: i32) -> anyhow::Result<()> {
        crate::service::MangaDomainService::validate_byte_size(new_size)?;
        self.byte_size = new_size;
        self.update_time = chrono::Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
        Ok(())
    }

    /// 设置描述
    ///
    /// # 参数
    /// - `description`: 描述内容
    pub fn set_description(&mut self, description: String) {
        self.description = Some(description);
        self.update_time = chrono::Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
    }

    /// 清除描述
    pub fn clear_description(&mut self) {
        self.description = None;
        self.update_time = chrono::Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
    }

    /// 设置作者
    ///
    /// # 参数
    /// - `author_id`: 作者 ID
    pub fn set_author(&mut self, author_id: i32) {
        self.author_id = Some(author_id);
        self.update_time = chrono::Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
    }

    /// 清除作者
    pub fn clear_author(&mut self) {
        self.author_id = None;
        self.update_time = chrono::Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
    }

    /// 判断是否有封面
    pub fn has_cover(&self) -> bool {
        self.cover.is_some()
    }

    /// 判断是否有描述
    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    /// 判断是否有作者
    pub fn has_author(&self) -> bool {
        self.author_id.is_some()
    }

    /// 获取封面 URL（如果没有封面，返回默认封面）
    pub fn get_cover_or_default(&self) -> String {
        self.cover.clone().unwrap_or_else(|| {
            format!("/api/manga/{}/cover", self.id)
        })
    }

    /// 设置图片路径列表
    ///
    /// # 参数
    /// - `paths`: 图片路径列表
    pub fn set_image_paths(&mut self, paths: Vec<String>) {
        self.image_paths = Some(serde_json::to_string(&paths).unwrap());
        self.update_time = chrono::Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
    }

    /// 获取图片路径列表
    ///
    /// # 返回
    /// - `Option<Vec<String>>` - 图片路径列表
    pub fn get_image_paths(&self) -> Option<Vec<String>> {
        self.image_paths.as_ref().and_then(|json| {
            serde_json::from_str(json).ok()
        })
    }

    /// 清除图片路径列表
    pub fn clear_image_paths(&mut self) {
        self.image_paths = None;
        self.update_time = chrono::Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
    }
}